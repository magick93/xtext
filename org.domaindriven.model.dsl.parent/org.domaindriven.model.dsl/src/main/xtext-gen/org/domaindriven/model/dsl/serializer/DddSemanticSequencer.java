/*
 * generated by Xtext 2.17.0.M2
 */
package org.domaindriven.model.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.domaindriven.model.dsl.services.DddGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import sculptormetamodel.Application;
import sculptormetamodel.Attribute;
import sculptormetamodel.BasicType;
import sculptormetamodel.CommandEvent;
import sculptormetamodel.Consumer;
import sculptormetamodel.DataTransferObject;
import sculptormetamodel.DomainEvent;
import sculptormetamodel.DomainObjectOperation;
import sculptormetamodel.Entity;
import sculptormetamodel.EnumConstructorParameter;
import sculptormetamodel.EnumValue;
import sculptormetamodel.Inheritance;
import sculptormetamodel.Publish;
import sculptormetamodel.Reference;
import sculptormetamodel.Repository;
import sculptormetamodel.RepositoryOperation;
import sculptormetamodel.Resource;
import sculptormetamodel.ResourceOperation;
import sculptormetamodel.SculptormetamodelPackage;
import sculptormetamodel.Service;
import sculptormetamodel.ServiceOperation;
import sculptormetamodel.Subscribe;
import sculptormetamodel.Trait;
import sculptormetamodel.ValueObject;

@SuppressWarnings("all")
public class DddSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DddGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SculptormetamodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SculptormetamodelPackage.APPLICATION:
				sequence_Application(context, (Application) semanticObject); 
				return; 
			case SculptormetamodelPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case SculptormetamodelPackage.BASIC_TYPE:
				sequence_BasicType(context, (BasicType) semanticObject); 
				return; 
			case SculptormetamodelPackage.COMMAND_EVENT:
				sequence_CommandEvent(context, (CommandEvent) semanticObject); 
				return; 
			case SculptormetamodelPackage.CONSUMER:
				sequence_Consumer(context, (Consumer) semanticObject); 
				return; 
			case SculptormetamodelPackage.DATA_TRANSFER_OBJECT:
				sequence_DataTransferObject(context, (DataTransferObject) semanticObject); 
				return; 
			case SculptormetamodelPackage.DOMAIN_EVENT:
				sequence_DomainEvent(context, (DomainEvent) semanticObject); 
				return; 
			case SculptormetamodelPackage.DOMAIN_OBJECT_OPERATION:
				sequence_DomainObjectOperation(context, (DomainObjectOperation) semanticObject); 
				return; 
			case SculptormetamodelPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case SculptormetamodelPackage.ENUM:
				sequence_Enum(context, (sculptormetamodel.Enum) semanticObject); 
				return; 
			case SculptormetamodelPackage.ENUM_CONSTRUCTOR_PARAMETER:
				sequence_EnumConstructorParameter(context, (EnumConstructorParameter) semanticObject); 
				return; 
			case SculptormetamodelPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case SculptormetamodelPackage.INHERITANCE:
				sequence_Inheritance(context, (Inheritance) semanticObject); 
				return; 
			case SculptormetamodelPackage.MODULE:
				sequence_Module(context, (sculptormetamodel.Module) semanticObject); 
				return; 
			case SculptormetamodelPackage.PARAMETER:
				sequence_Parameter(context, (sculptormetamodel.Parameter) semanticObject); 
				return; 
			case SculptormetamodelPackage.PUBLISH:
				sequence_Publish(context, (Publish) semanticObject); 
				return; 
			case SculptormetamodelPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case SculptormetamodelPackage.REPOSITORY:
				sequence_Repository(context, (Repository) semanticObject); 
				return; 
			case SculptormetamodelPackage.REPOSITORY_OPERATION:
				sequence_RepositoryOperation(context, (RepositoryOperation) semanticObject); 
				return; 
			case SculptormetamodelPackage.RESOURCE:
				sequence_Resource(context, (Resource) semanticObject); 
				return; 
			case SculptormetamodelPackage.RESOURCE_OPERATION:
				sequence_ResourceOperation(context, (ResourceOperation) semanticObject); 
				return; 
			case SculptormetamodelPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case SculptormetamodelPackage.SERVICE_OPERATION:
				sequence_ServiceOperation(context, (ServiceOperation) semanticObject); 
				return; 
			case SculptormetamodelPackage.SUBSCRIBE:
				sequence_Subscribe(context, (Subscribe) semanticObject); 
				return; 
			case SculptormetamodelPackage.TRAIT:
				sequence_Trait(context, (Trait) semanticObject); 
				return; 
			case SculptormetamodelPackage.VALUE_OBJECT:
				sequence_ValueObject_Impl(context, (ValueObject) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Application returns Application
	 *
	 * Constraint:
	 *     (name=EString doc=EString? hint=EString? basePackage=EString? (modules+=Module modules+=Module*)?)
	 */
	protected void sequence_Application(ISerializationContext context, Application semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (
	 *         nullable?='nullable'? 
	 *         naturalKey?='naturalKey'? 
	 *         required?='required'? 
	 *         index?='index'? 
	 *         transient?='transient'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         type=EString? 
	 *         collectionType=EString? 
	 *         mapKeyType=EString? 
	 *         changeable=EBoolean? 
	 *         databaseType=EString? 
	 *         visibility=EString? 
	 *         length=EString? 
	 *         databaseColumn=EString? 
	 *         validate=EString?
	 *     )
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainObject returns BasicType
	 *     BasicType returns BasicType
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         cache?='cache'? 
	 *         gapClass?='gapClass'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         optimisticLocking=EBoolean? 
	 *         package=EString? 
	 *         databaseTable=EString? 
	 *         extendsName=EString? 
	 *         validate=EString? 
	 *         discriminatorColumnValue=EString? 
	 *         aggregateRoot=EBoolean? 
	 *         immutable=EBoolean? 
	 *         persistent=EBoolean? 
	 *         extends=[DomainObject|EString]? 
	 *         inheritance=[Inheritance|EString]? 
	 *         belongsToAggregate=[DomainObject|EString]? 
	 *         (traits+=[Trait|EString] traits+=[Trait|EString]*)? 
	 *         (references+=Reference references+=Reference*)? 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         repository=Repository? 
	 *         (operations+=DomainObjectOperation operations+=DomainObjectOperation*)?
	 *     )
	 */
	protected void sequence_BasicType(ISerializationContext context, BasicType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainObject returns CommandEvent
	 *     Event returns CommandEvent
	 *     CommandEvent returns CommandEvent
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         cache?='cache'? 
	 *         gapClass?='gapClass'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         optimisticLocking=EBoolean? 
	 *         package=EString? 
	 *         databaseTable=EString? 
	 *         extendsName=EString? 
	 *         validate=EString? 
	 *         discriminatorColumnValue=EString? 
	 *         aggregateRoot=EBoolean? 
	 *         immutable=EBoolean? 
	 *         persistent=EBoolean? 
	 *         extends=[DomainObject|EString]? 
	 *         inheritance=[Inheritance|EString]? 
	 *         belongsToAggregate=[DomainObject|EString]? 
	 *         (traits+=[Trait|EString] traits+=[Trait|EString]*)? 
	 *         (references+=Reference references+=Reference*)? 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         repository=Repository? 
	 *         (operations+=DomainObjectOperation operations+=DomainObjectOperation*)?
	 *     )
	 */
	protected void sequence_CommandEvent(ISerializationContext context, CommandEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Consumer returns Consumer
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         channel=EString? 
	 *         (otherDependencies+=EString otherDependencies+=EString*)? 
	 *         (repositoryDependencies+=[Repository|EString] repositoryDependencies+=[Repository|EString]*)? 
	 *         (serviceDependencies+=[Service|EString] serviceDependencies+=[Service|EString]*)? 
	 *         messageRoot=[DomainObject|EString]? 
	 *         subscribe=[Subscribe|EString]?
	 *     )
	 */
	protected void sequence_Consumer(ISerializationContext context, Consumer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainObject returns DataTransferObject
	 *     DataTransferObject returns DataTransferObject
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         cache?='cache'? 
	 *         gapClass?='gapClass'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         optimisticLocking=EBoolean? 
	 *         package=EString? 
	 *         databaseTable=EString? 
	 *         extendsName=EString? 
	 *         validate=EString? 
	 *         discriminatorColumnValue=EString? 
	 *         aggregateRoot=EBoolean? 
	 *         immutable=EBoolean? 
	 *         persistent=EBoolean? 
	 *         extends=[DomainObject|EString]? 
	 *         inheritance=[Inheritance|EString]? 
	 *         belongsToAggregate=[DomainObject|EString]? 
	 *         (traits+=[Trait|EString] traits+=[Trait|EString]*)? 
	 *         (references+=Reference references+=Reference*)? 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         repository=Repository? 
	 *         (operations+=DomainObjectOperation operations+=DomainObjectOperation*)?
	 *     )
	 */
	protected void sequence_DataTransferObject(ISerializationContext context, DataTransferObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainObject returns DomainEvent
	 *     Event returns DomainEvent
	 *     DomainEvent returns DomainEvent
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         cache?='cache'? 
	 *         gapClass?='gapClass'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         optimisticLocking=EBoolean? 
	 *         package=EString? 
	 *         databaseTable=EString? 
	 *         extendsName=EString? 
	 *         validate=EString? 
	 *         discriminatorColumnValue=EString? 
	 *         aggregateRoot=EBoolean? 
	 *         immutable=EBoolean? 
	 *         persistent=EBoolean? 
	 *         extends=[DomainObject|EString]? 
	 *         inheritance=[Inheritance|EString]? 
	 *         belongsToAggregate=[DomainObject|EString]? 
	 *         (traits+=[Trait|EString] traits+=[Trait|EString]*)? 
	 *         (references+=Reference references+=Reference*)? 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         repository=Repository? 
	 *         (operations+=DomainObjectOperation operations+=DomainObjectOperation*)?
	 *     )
	 */
	protected void sequence_DomainEvent(ISerializationContext context, DomainEvent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainObjectOperation returns DomainObjectOperation
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         type=EString? 
	 *         collectionType=EString? 
	 *         mapKeyType=EString? 
	 *         throws=EString? 
	 *         visibility=EString? 
	 *         domainObjectType=[DomainObject|EString]? 
	 *         mapKeyDomainObjectType=[DomainObject|EString]? 
	 *         publish=[Publish|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 */
	protected void sequence_DomainObjectOperation(ISerializationContext context, DomainObjectOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainObject returns Entity
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         cache?='cache'? 
	 *         gapClass?='gapClass'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         optimisticLocking=EBoolean? 
	 *         package=EString? 
	 *         databaseTable=EString? 
	 *         extendsName=EString? 
	 *         validate=EString? 
	 *         discriminatorColumnValue=EString? 
	 *         aggregateRoot=EBoolean? 
	 *         auditable=EBoolean? 
	 *         extends=[DomainObject|EString]? 
	 *         inheritance=[Inheritance|EString]? 
	 *         belongsToAggregate=[DomainObject|EString]? 
	 *         (traits+=[Trait|EString] traits+=[Trait|EString]*)? 
	 *         (references+=Reference references+=Reference*)? 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         repository=Repository? 
	 *         (operations+=DomainObjectOperation operations+=DomainObjectOperation*)?
	 *     )
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumConstructorParameter returns EnumConstructorParameter
	 *
	 * Constraint:
	 *     value=EString?
	 */
	protected void sequence_EnumConstructorParameter(ISerializationContext context, EnumConstructorParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumValue returns EnumValue
	 *
	 * Constraint:
	 *     (name=EString doc=EString? hint=EString? (parameters+=EnumConstructorParameter parameters+=EnumConstructorParameter*)?)
	 */
	protected void sequence_EnumValue(ISerializationContext context, EnumValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainObject returns Enum
	 *     Enum returns Enum
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         cache?='cache'? 
	 *         gapClass?='gapClass'? 
	 *         ordinal?='ordinal'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         optimisticLocking=EBoolean? 
	 *         package=EString? 
	 *         databaseTable=EString? 
	 *         extendsName=EString? 
	 *         validate=EString? 
	 *         discriminatorColumnValue=EString? 
	 *         aggregateRoot=EBoolean? 
	 *         extends=[DomainObject|EString]? 
	 *         inheritance=[Inheritance|EString]? 
	 *         belongsToAggregate=[DomainObject|EString]? 
	 *         (traits+=[Trait|EString] traits+=[Trait|EString]*)? 
	 *         (references+=Reference references+=Reference*)? 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         repository=Repository? 
	 *         (operations+=DomainObjectOperation operations+=DomainObjectOperation*)? 
	 *         (values+=EnumValue values+=EnumValue*)?
	 *     )
	 */
	protected void sequence_Enum(ISerializationContext context, sculptormetamodel.Enum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Inheritance returns Inheritance
	 *
	 * Constraint:
	 *     (discriminatorColumnName=EString? discriminatorColumnLength=EString? type=InheritanceType? discriminatorType=DiscriminatorType?)
	 */
	protected void sequence_Inheritance(ISerializationContext context, Inheritance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (
	 *         external?='external'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         basePackage=EString? 
	 *         persistenceUnit=EString? 
	 *         (domainObjects+=DomainObject domainObjects+=DomainObject*)? 
	 *         (services+=Service services+=Service*)? 
	 *         (consumers+=Consumer consumers+=Consumer*)? 
	 *         (resources+=Resource resources+=Resource*)?
	 *     )
	 */
	protected void sequence_Module(ISerializationContext context, sculptormetamodel.Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         type=EString? 
	 *         collectionType=EString? 
	 *         mapKeyType=EString? 
	 *         domainObjectType=[DomainObject|EString]? 
	 *         mapKeyDomainObjectType=[DomainObject|EString]?
	 *     )
	 */
	protected void sequence_Parameter(ISerializationContext context, sculptormetamodel.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Publish returns Publish
	 *
	 * Constraint:
	 *     (eventBus=EString? topic=EString? eventType=[Event|EString]?)
	 */
	protected void sequence_Publish(ISerializationContext context, Publish semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     (
	 *         many?='many'? 
	 *         required?='required'? 
	 *         cache?='cache'? 
	 *         naturalKey?='naturalKey'? 
	 *         inverse?='inverse'? 
	 *         nullable?='nullable'? 
	 *         transient?='transient'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         collectionType=EString? 
	 *         cascade=EString? 
	 *         orderBy=EString? 
	 *         visibility=EString? 
	 *         changeable=EBoolean? 
	 *         fetch=EString? 
	 *         databaseColumn=EString? 
	 *         validate=EString? 
	 *         databaseJoinTable=EString? 
	 *         databaseJoinColumn=EString? 
	 *         opposite=[Reference|EString]? 
	 *         to=[DomainObject|EString]
	 *     )
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RepositoryOperation returns RepositoryOperation
	 *
	 * Constraint:
	 *     (
	 *         delegateToAccessObject?='delegateToAccessObject'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         type=EString? 
	 *         collectionType=EString? 
	 *         mapKeyType=EString? 
	 *         throws=EString? 
	 *         visibility=EString? 
	 *         accessObjectName=EString? 
	 *         domainObjectType=[DomainObject|EString]? 
	 *         mapKeyDomainObjectType=[DomainObject|EString]? 
	 *         publish=[Publish|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 */
	protected void sequence_RepositoryOperation(ISerializationContext context, RepositoryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Repository returns Repository
	 *
	 * Constraint:
	 *     (
	 *         gapClass?='gapClass'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         (otherDependencies+=EString otherDependencies+=EString*)? 
	 *         (repositoryDependencies+=[Repository|EString] repositoryDependencies+=[Repository|EString]*)? 
	 *         subscribe=[Subscribe|EString]? 
	 *         (operations+=RepositoryOperation operations+=RepositoryOperation*)?
	 *     )
	 */
	protected void sequence_Repository(ISerializationContext context, Repository semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ResourceOperation returns ResourceOperation
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         type=EString? 
	 *         collectionType=EString? 
	 *         mapKeyType=EString? 
	 *         throws=EString? 
	 *         visibility=EString? 
	 *         path=EString? 
	 *         httpMethod=HttpMethod? 
	 *         returnString=EString? 
	 *         domainObjectType=[DomainObject|EString]? 
	 *         mapKeyDomainObjectType=[DomainObject|EString]? 
	 *         publish=[Publish|EString]? 
	 *         delegate=[ServiceOperation|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 */
	protected void sequence_ResourceOperation(ISerializationContext context, ResourceOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Resource returns Resource
	 *
	 * Constraint:
	 *     (
	 *         gapClass?='gapClass'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         path=EString? 
	 *         (serviceDependencies+=[Service|EString] serviceDependencies+=[Service|EString]*)? 
	 *         (operations+=ResourceOperation operations+=ResourceOperation*)?
	 *     )
	 */
	protected void sequence_Resource(ISerializationContext context, Resource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ServiceOperation returns ServiceOperation
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         type=EString? 
	 *         collectionType=EString? 
	 *         mapKeyType=EString? 
	 *         throws=EString? 
	 *         visibility=EString? 
	 *         domainObjectType=[DomainObject|EString]? 
	 *         mapKeyDomainObjectType=[DomainObject|EString]? 
	 *         publish=[Publish|EString]? 
	 *         serviceDelegate=[ServiceOperation|EString]? 
	 *         delegate=[RepositoryOperation|EString]? 
	 *         (parameters+=Parameter parameters+=Parameter*)?
	 *     )
	 */
	protected void sequence_ServiceOperation(ISerializationContext context, ServiceOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (
	 *         gapClass?='gapClass'? 
	 *         webService?='webService'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         (otherDependencies+=EString otherDependencies+=EString*)? 
	 *         remoteInterface=EBoolean? 
	 *         localInterface=EBoolean? 
	 *         (repositoryDependencies+=[Repository|EString] repositoryDependencies+=[Repository|EString]*)? 
	 *         (serviceDependencies+=[Service|EString] serviceDependencies+=[Service|EString]*)? 
	 *         subscribe=[Subscribe|EString]? 
	 *         (operations+=ServiceOperation operations+=ServiceOperation*)?
	 *     )
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Subscribe returns Subscribe
	 *
	 * Constraint:
	 *     (eventBus=EString? topic=EString?)
	 */
	protected void sequence_Subscribe(ISerializationContext context, Subscribe semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainObject returns Trait
	 *     Trait returns Trait
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         cache?='cache'? 
	 *         gapClass?='gapClass'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         optimisticLocking=EBoolean? 
	 *         package=EString? 
	 *         databaseTable=EString? 
	 *         extendsName=EString? 
	 *         validate=EString? 
	 *         discriminatorColumnValue=EString? 
	 *         aggregateRoot=EBoolean? 
	 *         extends=[DomainObject|EString]? 
	 *         inheritance=[Inheritance|EString]? 
	 *         belongsToAggregate=[DomainObject|EString]? 
	 *         (traits+=[Trait|EString] traits+=[Trait|EString]*)? 
	 *         (references+=Reference references+=Reference*)? 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         repository=Repository? 
	 *         (operations+=DomainObjectOperation operations+=DomainObjectOperation*)?
	 *     )
	 */
	protected void sequence_Trait(ISerializationContext context, Trait semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainObject returns ValueObject
	 *     ValueObject_Impl returns ValueObject
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         cache?='cache'? 
	 *         gapClass?='gapClass'? 
	 *         name=EString 
	 *         doc=EString? 
	 *         hint=EString? 
	 *         optimisticLocking=EBoolean? 
	 *         package=EString? 
	 *         databaseTable=EString? 
	 *         extendsName=EString? 
	 *         validate=EString? 
	 *         discriminatorColumnValue=EString? 
	 *         aggregateRoot=EBoolean? 
	 *         immutable=EBoolean? 
	 *         persistent=EBoolean? 
	 *         extends=[DomainObject|EString]? 
	 *         inheritance=[Inheritance|EString]? 
	 *         belongsToAggregate=[DomainObject|EString]? 
	 *         (traits+=[Trait|EString] traits+=[Trait|EString]*)? 
	 *         (references+=Reference references+=Reference*)? 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         repository=Repository? 
	 *         (operations+=DomainObjectOperation operations+=DomainObjectOperation*)?
	 *     )
	 */
	protected void sequence_ValueObject_Impl(ISerializationContext context, ValueObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
